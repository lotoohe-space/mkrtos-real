.syntax unified
.cpu cortex-m4
.fpu softvfp
.thumb

globalptr .req r10  //=wram_globals* ptr 6502的基准指针
//----------------------------------------------------------------------------

//MAP 0,globalptr		  //MAP 用于定义一个结构化的内存表的首地址
							//定义内存表的首地址为globalptr
#define opz [globalptr,#(0)]//#4              ////opz # 256*4       ////代码表地址					  
#define readmem_tbl [globalptr,#(4)]//#32			  //8*4
#define writemem_tbl [globalptr,#(4+32)]//#32			  //8*4
#define writemem_tbl_16 [globalptr,#(4+32+16)]//#32
#define writemem_tbl_20 [globalptr,#(4+32+20)]//#32
#define writemem_tbl_24 [globalptr,#(4+32+24)]//#32
#define writemem_tbl_28 [globalptr,#(4+32+28)]//#32
#define memmap_tbl [globalptr,#(4+32+32)]//#32			 //(8*4)存储器映象 ram+rom
#define memmap_tbl_4 [globalptr,#(4+32+32+4)]//#32			 //
#define memmap_tbl_8 [globalptr,#(4+32+32+8)]//#32			 //
#define memmap_tbl_12 [globalptr,#(4+32+32+12)]//#32			 //
#define memmap_tbl_16 [globalptr,#(4+32+32+16)]//#32			 //
#define memmap_tbl_20 [globalptr,#(4+32+32+20)]//#32			 //
#define memmap_tbl_24 [globalptr,#(4+32+32+24)]//#32			 //
#define memmap_tbl_28 [globalptr,#(4+32+32+28)]//#32			 //
#define cpuregs [globalptr,#(4+32+32+32)]//#28				 //(7*4)1208存放6502寄存器保存的开始地址
#define m6502_s [globalptr,#(4+32+32+32+28)]//#4					 
#define lastbank [globalptr,#(4+32+32+32+28+4)]//#4				//6502PC从 ROM的最后偏移量
#define nexttimeout [globalptr,#(4+32+32+32+28+4+4)]//#4

#define rombase [globalptr,#(4+32+32+32+28+4+4+4)]//#4			//ROM开始地址
#define romnumber [globalptr,#(4+32+32+32+28+4+4+4+4)]//#4		 //ROM大小  
#define rommask [globalptr,#(4+32+32+32+28+4+4+4+4+4)]//#4		   //ROM掩膜	rommask=romsize-1

#define joy0data [globalptr,#(4+32+32+32+28+4+4+4+4+4+4)]//#4	   //串行数据
#define joy1data [globalptr,#(4+32+32+32+28+4+4+4+4+4+4+4)]//#4	   //手柄1串行数据

#define clocksh [globalptr,#(4+32+32+32+28+4+4+4+4+4+4+4+4)]//#4    //执行的时钟数 apu用
#define cpunmif [globalptr,#(4+32+32+32+28+4+4+4+4+4+4+4+4+4)]//#4      //cpu中断标志
#define cpuirqf [globalptr,#(4+32+32+32+28+4+4+4+4+4+4+4+4+4+4)]//#4      //cpu中断标志   43*4

//***********************************************************************************************
.equ C , 0x01 //6502 flags  6502标志
.equ Z , 0x02
.equ I , 0x04
.equ D , 0x08
.equ B , 0x10 //(allways 1 except when IRQ pushes it)IRQ外部中断
.equ R , 0x20
.equ V , 0x40 //(locked at 1)
.equ N , 0x80


.macro encodePC	//translate from 6502 PC to rom offset翻译从6502 PC ROM的偏移量

	and r1,m6502_pc,#0xE000	   ////r9和0xe000按位与运算
	
	@adr r2,memmap_tbl		   ////adr 把存储器映象地址加载到r2
	mov r2,globalptr
	add r2,r2,#(4+32+32)

	//ldr r0,[r2,r1,lsr#11]	   ////改过，加2行 //单指令在F1C100S ARM9也可以--By Liang  
	lsr r0,r1,#11				////>>11位	  r1/2048
	ldr r0,[r2,r0]				////读取r2地址+r1偏移的数据到r0
	
	str r0,lastbank				////保存6502PC从 ROM的最后偏移量 
	add m6502_pc,m6502_pc,r0	////m6502_pc+r0
.endm

.macro encodeP extra	//pack 6502 flags into r0   6502标志包装到R0
	
	and r0,cycles,#CYC_V+CYC_D+CYC_I+CYC_C
	tst m6502_nz,#0x80000000  //PSR_N
	orrne r0,r0,#N				//N
	tst m6502_nz,#0xff
	orreq r0,r0,#Z				//Z
	orr r0,r0,#\extra			//R(&B)
.endm

.macro	decodeP	//unpack 6502 flags from r0	  解压缩6502从R0的标志
	bic cycles,cycles,#CYC_V+CYC_D+CYC_I+CYC_C
	and r1,r0,#V+D+I+C
	orr cycles,cycles,r1		//VDIC
	bic m6502_nz,r0,#0xFD			//r0 is signed
	eor m6502_nz,m6502_nz,#Z
.endm		//	

.macro fetch count	
			   //提取操作码	//$标号 宏名 $参数1，$参数2，...
//---------------------------------------------------------------------
	ldr r0,clocksh			   //处理apu需要的时钟数
	add r0,r0,#\count
	str r0,clocksh

	ldr r1,opz            //获取代码跳转表地址
//-------------------------------------------------------------------------
	subs cycles,cycles,#\count*256   //CYCLE=256 ////	3*256 正数或0就执行下2条指令  
	ldrplb r0,[m6502_pc],#1			   //从存储器中加载字节到一个寄存器中	 r0=操作码
//	ldrpl pc,[m6502_optbl,r0,lsl#2]	  //r10 ********r0=r0x4***运行代码的地址**************************************
	ldrpl r0,[r1,r0,lsl#2]
	orrpl r0,r0,#0x1
	bxpl r0
	ldr r0,nexttimeout
	orr r0, r0, #0x1
	bx r0
.endm

.macro fetch_c count					//相同的提取，但它增加了进位（位0）
					//same as fetch except it adds the Carry (bit 0) also.
//---------------------------------------------------------------------
	ldr r0,clocksh				//处理apu需要的时钟数
	add r0,r0,#\count
	str r0,clocksh	
	
	ldr r1,opz       //获取代码跳转表地址
//-------------------------------------------------------------------------
	sbcs cycles,cycles,#\count*256  //CYCLE=256
	ldrplb r0,[m6502_pc],#1
//	ldrpl pc,[m6502_optbl,r0,lsl#2]
	ldrpl r0,[r1,r0,lsl#2]
	orrpl r0,r0,#0x1
	bxpl r0
	ldr r0,nexttimeout
	orr r0, r0, #0x1
	bx r0
.endm

.macro clearcycles
	
	and cycles,cycles,#CYC_MASK		//Save CPU bits
.endm

.macro readmemabs
	
	and r1,addy,#0xE000
	adr lr,0f
//	ldr pc,[m6502_rmem,r1,lsr#11]	//in: addy,r1=addy&0xE000 (for rom_R)
	lsr r1,r1,#11				 //改过，加2行	 >>11
	mov r0,globalptr
	add r0,r0,#(4)
	ldr r0,[r0,r1]
	orr r0,r0,#0x1
	bx r0
				
0:				//out: r0=val (bits 8-31=0 (LSR,ROR,INC,DEC,ASL)), addy preserved for RMW instructions
.endm

.macro readmemzp
	ldrb r0,[cpu_zpage,addy]
.endm

.macro readmemzpi
//	ldrb r0,[cpu_zpage,addy,lsr#24]
	lsr r0,addy,#24				  //改过，加3行
	ldrb r0,[cpu_zpage,r0]

.endm

.macro readmemzps
	ldrsb m6502_nz,[cpu_zpage,addy] //RAM
.endm

.macro readmemimm
	ldrb r0,[m6502_pc],#1  //ROM
.endm

.macro readmemimms
	ldrsb m6502_nz,[m6502_pc],#1
.endm

.macro readmem
	.if _type == _ABS
		readmemabs
	.endif
	.if _type == _ZP
		readmemzp
	.endif
	.if _type == _ZPI
		readmemzpi
	.endif
	.if _type == _IMM
		readmemimm
	.endif
.endm

.macro readmems
	.if _type == _ABS
		readmemabs
		orr m6502_nz,r0,r0,lsl#24
	.endif
	.if _type == _ZP
		readmemzps
	.endif
	.if _type == _IMM
		readmemimms
	.endif
.endm


.macro writememabs
	and r1,addy,#0xe000
	@adr r2,writemem_tbl
	mov r2,globalptr
	add r2,r2,#(4+32) 

	adr lr,0f
//	ldr pc,[r2,r1,lsr#11]	//in: addy,r0=val(bits 8-31=?)
	lsr r1,r1,#11				 //改过，加2行 >>11
	ldr r1,[r2,r1]
	orr r1,r1,#0x1
	bx r1
0:				//out: r0,r1,r2,addy=?
.endm

.macro writememzp
	strb r0,[cpu_zpage,addy]
.endm

.macro writememzpi
//	strb r0,[cpu_zpage,addy,lsr#24]
	lsr r1,addy,#24				 //改过，加2行	 >>24
	strb r0,[cpu_zpage,r1]
.endm

.macro writemem
			   //写内存
	.if _type == _ABS
		writememabs
	.endif
	.if _type == _ZP
		writememzp
	.endif
	.if _type == _ZPI
		writememzpi
	.endif
.endm
//----------------------------------------------------------------------------

.macro	push16				 
			//push r0
	mov r1,r0,lsr#8
	ldr r2,m6502_s
	strb r1,[r2],#-1
	orr r2,r2,#0x100
	strb r0,[r2],#-1
	strb r2,m6502_s
.endm		//r1,r2=?

.macro push8 x
	ldr r2,m6502_s
	strb \x,[r2],#-1
	strb r2,m6502_s
.endm		//r2=?

.macro pop16
			//pop m6502_pc
	ldrb r2,m6502_s
	add r2,r2,#2
	strb r2,m6502_s
	ldr r2,m6502_s
	ldrb r0,[r2],#-1
	orr r2,r2,#0x100
	ldrb m6502_pc,[r2]
	orr m6502_pc,m6502_pc,r0,lsl#8
.endm		//r0,r1=?

.macro pop8 x
	ldrb r2,m6502_s
	add r2,r2,#1
	strb r2,m6502_s
	orr r2,r2,#0x100
	ldrsb \x,[cpu_zpage,r2]		//signed for PLA & PLP

.endm	//r2=?

//----------------------------------------------------------------------------
//doXXX: load addy, increment m6502_pc

.global _type

.equ _IMM , 1						//immediate
.equ _ZP  , 2						//zero page
.equ _ZPI ,3						//zero page indexed
.equ _ABS ,4						//absolute

.macro doABS
                          //absolute               $nnnn
.equ _type , _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
.endm

.macro doAIX
	                           //absolute indexed X     $nnnn,X
.equ _type , _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
	add addy,addy,m6502_x,lsr#24
//	bic addy,addy,#0xff0000 //Base Wars needs this
.endm

.macro doAIY
	                           //absolute indexed Y     $nnnn,Y
.equ _type , _ABS
	ldrb addy,[m6502_pc],#1
	ldrb r0,[m6502_pc],#1
	orr addy,addy,r0,lsl#8
	add addy,addy,m6502_y,lsr#24
//	bic addy,addy,#0xff0000 //Tecmo Bowl needs this
.endm

.macro doIMM
	                           //immediate              #$nn
.equ _type , _IMM
.endm

.macro doIIX
	                           //indexed indirect X     ($nn,X)
.equ _type , _ABS
	ldrb r0,[m6502_pc],#1
	add r0,m6502_x,r0,lsl#24
	//ldrb addy,[cpu_zpage,r0,lsr#24]	//错误:指定的转变不允许
    lsr addy,r0,#24			  //改过，加2行 >>24
	ldrb addy,[cpu_zpage,addy]

	add r0,r0,#0x01000000
	//ldrb r1,[cpu_zpage,r0,lsr#24]	//R1,LSR#2//将R1中的内容右移2位
	lsr r1,r0,#24			  //改过，加2行
	ldrb r1,[cpu_zpage,r1]

	orr addy,addy,r1,lsl#8
.endm

.macro doIIY
	                           //indirect indexed Y     ($nn),Y
.equ _type , _ABS
	ldrb r0,[m6502_pc],#1
//	ldrb addy,[r0,cpu_zpage]! //在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            ////若使用后缀"!",则结果写回到Rn中
	ldrb addy,[r0,cpu_zpage]
	add r0,r0,cpu_zpage			//////////////////////////////////////


	ldrb r1,[r0,#1]
	orr addy,addy,r1,lsl#8
	add addy,addy,m6502_y,lsr#24
//	bic addy,addy,#0xff0000 //Zelda2 needs this
.endm

.macro doZPI
								//Zeropage indirect     ($nn)
.equ _type , _ABS
	ldrb r0,[m6502_pc],#1
//	ldrb addy,[r0,cpu_zpage]! //在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            //若使用后缀"!",则结果写回到Rn中
	ldrb addy,[r0,cpu_zpage]
	add r0,r0,cpu_zpage	
	
	
	ldrb r1,[r0,#1]
	orr addy,addy,r1,lsl#8
.endm

.macro doZ
	                             //zero page              $nn
.equ _type , _ZP
	ldrb addy,[m6502_pc],#1
.endm

.macro doZ2
								//zero page              $nn
.equ _type , _ZP
	ldrb addy,[m6502_pc],#2			//ugly thing for bbr/bbs
.endm

.macro doZIX
	                           //zero page indexed X    $nn,X
.equ _type , _ZP
	ldrb addy,[m6502_pc],#1
	add addy,addy,m6502_x,lsr#24
	and addy,addy,#0xff //Rygar needs this
.endm

.macro doZIXf
								//zero page indexed X    $nn,X
.equ _type , _ZPI
	ldrb addy,[m6502_pc],#1
	add addy,m6502_x,addy,lsl#24
.endm

.macro doZIY
	                           //zero page indexed Y    $nn,Y
.equ _type , _ZP
	ldrb addy,[m6502_pc],#1
	add addy,addy,m6502_y,lsr#24
	and addy,addy,#0xff
.endm

.macro doZIYf
								///zero page indexed Y    $nn,Y
.equ _type , _ZPI
	ldrb addy,[m6502_pc],#1
	add addy,m6502_y,addy,lsl#24
.endm

///----------------------------------------------------------------------------

.macro opADC
	
	readmem
	movs r1,cycles,lsr#1		//get C
	subcs r0,r0,#0x00000100
	adcs m6502_a,m6502_a,r0,ror#8
	mov m6502_nz,m6502_a,asr#24		//NZ
	orr cycles,cycles,#CYC_C+CYC_V	//Prepare C & V
	bicvc cycles,cycles,#CYC_V	//V
.endm

.macro opAND
	readmem
	and m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24		//NZ
.endm

.macro opASL
	readmem
	 add r0,r0,r0
	 orrs m6502_nz,r0,r0,lsl#24		//NZ
	 orr cycles,cycles,#CYC_C		//Prepare C
	writemem
.endm

.macro opBIT
	readmem
	bic cycles,cycles,#CYC_V		//reset V
	tst r0,#V
	orrne cycles,cycles,#CYC_V		//V
	and m6502_nz,r0,m6502_a,lsr#24	//Z
	orr m6502_nz,m6502_nz,r0,lsl#24	//N
.endm

.macro opCOMP x
				//A,X & Y
	readmem
	subs m6502_nz,\x,r0,lsl#24
	mov m6502_nz,m6502_nz,asr#24	//NZ
	orr cycles,cycles,#CYC_C	//Prepare C
.endm

.macro opDEC
	readmem
	sub r0,r0,#1
	orr m6502_nz,r0,r0,lsl#24		//NZ
	writemem
.endm

.macro opEOR
	readmem
	eor m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24		//NZ
.endm

.macro opINC
	readmem
	add r0,r0,#1
	orr m6502_nz,r0,r0,lsl#24		//NZ
	writemem
.endm

.macro opLOAD x
	readmems
	mov \x,m6502_nz,lsl#24
.endm

.macro opLSR
	
	.if _type == _ABS
		readmemabs
		movs r0,r0,lsr#1
		orr cycles,cycles,#CYC_C	//Prepare C
		mov m6502_nz,r0				//Z, (N=0)
		writememabs
	.endif
	.if _type == _ZP
		ldrb m6502_nz,[cpu_zpage,addy]
		movs m6502_nz,m6502_nz,lsr#1	//Z, (N=0)
		orr cycles,cycles,#CYC_C	//Prepare C
		strb m6502_nz,[cpu_zpage,addy]
	.endif
	.if _type == _ZPI
//		ldrb m6502_nz,[cpu_zpage,addy,lsr#24]
		lsr m6502_nz,addy,#24				  //改过，加2行
		ldrb m6502_nz,[cpu_zpage,m6502_nz]

		movs m6502_nz,m6502_nz,lsr#1	//Z, (N=0)
		orr cycles,cycles,#CYC_C	//Prepare C
//		strb m6502_nz,[cpu_zpage,addy,lsr#24]
		lsr r1,addy,#24				   //改过，加2行
		strb m6502_nz,[cpu_zpage,r1]						 
	.endif
.endm

.macro opORA
	readmem
	orr m6502_a,m6502_a,r0,lsl#24
	mov m6502_nz,m6502_a,asr#24
.endm

.macro opROL
	readmem
	 movs cycles,cycles,lsr#1		//get C
	 adc r0,r0,r0
	 orrs m6502_nz,r0,r0,lsl#24		//NZ
	 adc cycles,cycles,cycles		//Set C
	writemem
.endm

.macro opROR
	readmem
	 movs cycles,cycles,lsr#1		//get C
	 orrcs r0,r0,#0x100
	 movs r0,r0,lsr#1
	 orr m6502_nz,r0,r0,lsl#24		//NZ
	 adc cycles,cycles,cycles		//Set C
	writemem
.endm

.macro opSBC
	readmem
	movs r1,cycles,lsr#1			//get C
	sbcs m6502_a,m6502_a,r0,lsl#24
	and m6502_a,m6502_a,#0xff000000
	mov m6502_nz,m6502_a,asr#24 		//NZ
	orr cycles,cycles,#CYC_C+CYC_V	//Prepare C & V
	bicvc cycles,cycles,#CYC_V		//V
.endm

.macro opSTORE x
	mov r0,\x,lsr#24
	writemem
.endm
//*************************************************************************************************

	.extern NES_RAM		 //nes_main.c   __align(1024) uint8 NES_RAM[0x800]////保持1024字节对齐
	.extern NES_SRAM		 //nes_main.c   uint8 NES_SRAM[0x2000]//	
	.extern spr_ram		 //--         uint8 spr_ram[0x100]//
	.extern romfile //from main.c	

	.global cpunmi    //cpu中断标志
	.global cpuirq    //cpu中断标志 
	.global clocks    //apu要的cpu时钟
	.global cpu_data	   //地址 cart.s
	/* .global rommap
	.global NMI6502
	.global CPU_reset
	.global run6502
		
	.global cpu6502_init
	.global map67_	
	.global map67_0	
	.global map89_
	.global mapAB_
	.global mapCD_
	.global mapEF_	
	.global map89ABCDEF_*/

.equ IRQ_VECTOR	, 0xfffe //IRQ / BRK中断向量地址
.equ RES_VECTOR	, 0xfffc // 复位中断向量地址
.equ NMI_VECTOR	, 0xfffa // NMI中断向量地址

//cycle flags- (stored in cycles reg for speed)存储在周期章速度

.equ CYC_C		, 0x01	//Carry bit 进位
//.equ BRANCH	, 0x02	//branch instruction encountered	遇到分支指令
.equ CYC_I		, 0x04	//IRQ mask
.equ CYC_D		, 0x08	//Decimal bit	小数位
.equ CYC_V		, 0x40	//Overflow bit	 溢出位
//.equ CYC_MASK	, 0xFF//CYCLE-1	//Mask

.text //, ALIGN=2
											//	不要对 ARM 代码节使用 ALIGN=0 或 ALIGN=1。
                                           //--不要对 Thumb 代码节使用 ALIGN=0。
   //AREA  伪代码也是需要语法的，AREA  后面跟着段名标号，然后是属性，CODE 表示这是一 
	//个代码段，READONLY 表示这个段是只读的
	//|.text|系统默认的代码段名  
	// ALIGN 指令通过用零或 NOP 指令进行填充将当前位置对齐到指定边界
	//ENTRY  这个伪代码是用来定义入口点
//	THUMB	 //Thumb是ARM体系结构中一种16位的指令集
//	REQUIRE8  //REQUIRE8 指令指定当前文件要求堆栈八字节对齐。 它设置 REQ8 编译属性以通知链接器。
//	PRESERVE8 //{TRUE} //PRESERVE8 指令指定当前文件保持堆栈八字节对齐。 它设置 PRES8 编译属性以通知链接器。
			  //如果您省略 PRESERVE8 和 PRESERVE8 {FALSE}，汇编程序会检查修改 sp 的指令，
			  //以决定是否设置 PRES8 编译属性。 ARM 建议明确指定 PRESERVE8。
			  // ARM使用r0作为返回值
			  //参数传递ARM：寄存器到堆栈，首先将参数赋给r0, r1等

 //  PROC 为子程序开始，ENDP 为子程序结束
.align 8

		//r0,r1,r2=temp regs	  
	
 m6502_nz	.req r3 //bit 31=N, Z=1 if bits 0-7=0		  //RN定义寄存器名
 ram_offset .req r4 //readmem_tbl
 m6502_a .req r5 ////bits 0-23=0, 还用于清除在内存中的字节
 m6502_x .req r6 //bits 0-23=0
 m6502_y .req r7 //bits 0-23=0
 cycles .req r8 ////also VDIC flags也VDIC标志
 m6502_pc .req r9
 globalptr .req r10 //=wram_globals* ptr
 m6502_optbl .req r10
 cpu_zpage .req  r11 //=CPU_RAM
 addy .req r12 //keep this at r12 (从头 APCS)	//addr  :代表8位地址 
		//r13=SP
		//r14=LR
		//r15=PC
//---------------------------------------------------
	

_P00://   BRK
//----------------------------------------------------------------------------
	ldr r0,lastbank		 //	  6502PC从 ROM的最后偏移量
	sub r1,m6502_pc,r0
	add r0,r1,#1
	push16			//save PC

	encodeP (B+R)		//save P

	ldr r12,=IRQ_VECTOR
	bl VecCont

	fetch 7
	.ltorg			 //指令， LTORG可能是在一个可执行的位置
//----------------------------------------------------------------------------
_P01://   ORA ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opORA
	fetch 6
//----------------------------------------------------------------------------
_P05://   ORA $nn
//----------------------------------------------------------------------------
	doZ
	opORA
	fetch 3
//----------------------------------------------------------------------------
_P06://   ASL $nn
//----------------------------------------------------------------------------
	doZ
	opASL
	fetch_c 5
//----------------------------------------------------------------------------
_P08://   PHP
//----------------------------------------------------------------------------
	encodeP (B+R)
	push8 r0
	fetch 3
//----------------------------------------------------------------------------
_P09://  ORA #$nn
//----------------------------------------------------------------------------
	doIMM
	opORA
	fetch 2
//----------------------------------------------------------------------------
_P0A://   ASL
//----------------------------------------------------------------------------
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		//NZ
	orr cycles,cycles,#CYC_C		//Prepare C
	fetch_c 2						//also subs carry
//----------------------------------------------------------------------------
_P0D://   ORA $nnnn
//----------------------------------------------------------------------------
	doABS
	opORA
	fetch 4
//----------------------------------------------------------------------------
_P0E://   ASL $nnnn
///----------------------------------------------------------------------------
	doABS
	opASL
	fetch_c 6
//----------------------------------------------------------------------------	 
_P10://   BPL *
//----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
//	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_P11://   ORA ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opORA
	fetch 5
//----------------------------------------------------------------------------
_P15://   ORA $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opORA
	fetch 4
//----------------------------------------------------------------------------
_P16://  ASL $nn,X
//---------------------------------------------------------------------------
	doZIXf
	opASL
	fetch_c 6
//----------------------------------------------------------------------------
_P18://   CLC
//---------------------------------------------------------------------------
	bic cycles,cycles,#CYC_C
	fetch 2
//---------------------------------------------------------------------------
_P19://  ORA $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opORA
	fetch 4
//---------------------------------------------------------------------------
_P1D://--ORA $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opORA
	fetch 4
//----------------------------------------------------------------------------
_P1E://--ASL $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opASL
	fetch_c 7
//----------------------------------------------------------------------------
_P20://--JSR $nnnn
//----------------------------------------------------------------------------
	ldrb r2,[m6502_pc],#1
	ldr r1,lastbank
	sub r0,m6502_pc,r1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r2,r1,lsl#8
	push16
	encodePC
	fetch 6
//----------------------------------------------------------------------------
_P21://--AND ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opAND
	fetch 6
//----------------------------------------------------------------------------
_P24://--BIT $nn
//----------------------------------------------------------------------------
	doZ
	opBIT
	fetch 3
//----------------------------------------------------------------------------
_P25://--AND $nn
//----------------------------------------------------------------------------
	doZ
	opAND
	fetch 3
//----------------------------------------------------------------------------
_P26://--ROL $nn
//----------------------------------------------------------------------------
	doZ
	opROL
	fetch 5
//----------------------------------------------------------------------------
_P28://--PLP
//----------------------------------------------------------------------------
	pop8 r0
	decodeP
	fetch 4
//----------------------------------------------------------------------------
_P29://--AND #$nn
//----------------------------------------------------------------------------
	doIMM
	opAND
	fetch 2
//----------------------------------------------------------------------------
_P2A://--ROL
//----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		//get C
	orrcs m6502_a,m6502_a,#0x00800000
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		//NZ
	adc cycles,cycles,cycles		//Set C
	fetch 2
//----------------------------------------------------------------------------
_P2C://--BIT $nnnn
//----------------------------------------------------------------------------
	doABS
	opBIT
	fetch 4
//----------------------------------------------------------------------------
_P2D://--AND $nnnn
//----------------------------------------------------------------------------
	doABS
	opAND
	fetch 4
//----------------------------------------------------------------------------
_P2E://--ROL $nnnn
//----------------------------------------------------------------------------
	doABS
	opROL
	fetch 6
//----------------------------------------------------------------------------
_P30://--BMI *
//----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
//	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_P31://--AND ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opAND
	fetch 5
//----------------------------------------------------------------------------
_P35://--AND $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opAND
	fetch 4
//----------------------------------------------------------------------------
_P36://--ROL $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opROL
	fetch 6
//----------------------------------------------------------------------------
_P38://--SEC
//----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_C
	fetch 2
//----------------------------------------------------------------------------
_P39://--AND $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opAND
	fetch 4
//----------------------------------------------------------------------------
_P3D://--AND $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opAND
	fetch 4
//----------------------------------------------------------------------------
_P3E://--ROL $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opROL
	fetch 7
//----------------------------------------------------------------------------
_P40://--RTI
//----------------------------------------------------------------------------
	pop8 r0		//pop 6502 flags and decode
	decodeP
	pop16		//pop the return address
	encodePC
	fetch 6
//----------------------------------------------------------------------------
_P41://--EOR ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opEOR
	fetch 6
//----------------------------------------------------------------------------
_P45://--EOR $nn
//----------------------------------------------------------------------------
	doZ
	opEOR
	fetch 3
//----------------------------------------------------------------------------
_P46://--LSR $nn
//----------------------------------------------------------------------------
	doZ
	opLSR
	fetch_c 5
//----------------------------------------------------------------------------
_P48://--PHA
//----------------------------------------------------------------------------
	mov r0,m6502_a,lsr#24
	push8 r0
	fetch 3
//----------------------------------------------------------------------------
_P49://--EOR #$nn
//----------------------------------------------------------------------------
	doIMM
	opEOR
	fetch 2
//----------------------------------------------------------------------------
_P4A://--LSR
//----------------------------------------------------------------------------
	movs m6502_nz,m6502_a,lsr#25	//Z, N=0
	mov m6502_a,m6502_nz,lsl#24		//result without garbage
	orr cycles,cycles,#CYC_C		//Prepare C
	fetch_c 2
//----------------------------------------------------------------------------
_P4C://--JMP $nnnn
//----------------------------------------------------------------------------
	ldrb r0,[m6502_pc],#1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r0,r1,lsl#8
	encodePC
	fetch 3
//----------------------------------------------------------------------------
_P4D://--EOR $nnnn
//----------------------------------------------------------------------------
	doABS
	opEOR
	fetch 4
//----------------------------------------------------------------------------
_P4E://--LSR $nnnn
//----------------------------------------------------------------------------
	doABS
	opLSR
	fetch_c 6
//----------------------------------------------------------------------------
_P50://--BVC *
//----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
//	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_P51://--EOR ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opEOR
	fetch 5
//----------------------------------------------------------------------------
_P55://--EOR $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opEOR
	fetch 4
//----------------------------------------------------------------------------
_P56://--LSR $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opLSR
	fetch_c 6
//----------------------------------------------------------------------------
_P58://--CLI
//----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_I
	fetch 2
//----------------------------------------------------------------------------
_P59://--EOR $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opEOR
	fetch 4
//----------------------------------------------------------------------------
_P5D://--EOR $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opEOR
	fetch 4
//----------------------------------------------------------------------------
_P5E://--LSR $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opLSR
	fetch_c 7
//----------------------------------------------------------------------------
_P60://--RTS
//----------------------------------------------------------------------------
	pop16
	add m6502_pc,m6502_pc,#1
	encodePC
	fetch 6
//----------------------------------------------------------------------------
_P61://--ADC ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opADC
	fetch_c 6
//----------------------------------------------------------------------------
_P65://--ADC $nn
//----------------------------------------------------------------------------
	doZ
	opADC
	fetch_c 3
//----------------------------------------------------------------------------
_P66://--ROR $nn
//----------------------------------------------------------------------------
	doZ
	opROR
	fetch 5
//----------------------------------------------------------------------------
_P68://--PLA
//----------------------------------------------------------------------------
	pop8 m6502_nz
	mov m6502_a,m6502_nz,lsl#24
	fetch 4
//----------------------------------------------------------------------------
_P69://--ADC #$nn
//----------------------------------------------------------------------------
	doIMM
	opADC
	fetch_c 2
//----------------------------------------------------------------------------
_P6A://--ROR
//----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		//get C
	mov m6502_a,m6502_a,rrx
	movs m6502_nz,m6502_a,asr#24	//NZ
	and m6502_a,m6502_a,#0xff000000
	adc cycles,cycles,cycles		//Set C
	fetch 2
//----------------------------------------------------------------------------
_P6C://--JMP ($nnnn)	JMP ($data16) 间接寻址 *********************************
//----------------------------------------------------------------------------		
	doABS       
	@ adr r1,memmap_tbl		
	mov r1,globalptr
	add r1,r1,#(4+32+32)

	and r2,addy,#0xE000	//		  
//	ldr r1,[r1,r2,lsr#11]  		  />>11 addr&0x7FF
	lsr r0,r2,#11			  
	ldr r1,[r1,r0]		   //在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
							   
	ldrb m6502_pc,[r1,addy]     //若使用后缀"!",则结果写回到Rn中
	add r1,r1,addy	    

	ldrb r0,[r1,#1]	    
	orr m6502_pc,m6502_pc,r0,lsl#8	 //m6502_pc=r9使用ORR 指令将近R9的高8 位数据移入到R0低8位
	encodePC	
	fetch 5
//----------------------------------------------------------------------------
_P6D://--ADC $nnnn
//----------------------------------------------------------------------------
	doABS
	opADC
	fetch_c 4
//----------------------------------------------------------------------------
_P6E://--ROR $nnnn
//----------------------------------------------------------------------------
	doABS
	opROR
	fetch 6
//----------------------------------------------------------------------------
_P70://--BVS *
//----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
//	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_P71://--ADC ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opADC
	fetch_c 5
//----------------------------------------------------------------------------
_P75://--ADC $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opADC
	fetch_c 4
//----------------------------------------------------------------------------
_P76://--ROR $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opROR
	fetch 6
//----------------------------------------------------------------------------
_P78://--SEI
//----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_I
	fetch 2
//----------------------------------------------------------------------------
_P79://--ADC $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opADC
	fetch_c 4
//----------------------------------------------------------------------------
_P7D://--ADC $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opADC
	fetch_c 4
//----------------------------------------------------------------------------
_P7E://--ROR $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opROR
	fetch 7
//----------------------------------------------------------------------------
_P81://--STA ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opSTORE m6502_a
	fetch 6
//----------------------------------------------------------------------------
_P84://--STY $nn
//----------------------------------------------------------------------------
	doZ
	opSTORE m6502_y
	fetch 3
//----------------------------------------------------------------------------
_P85://--STA $nn
//----------------------------------------------------------------------------
	doZ
	opSTORE m6502_a
	fetch 3
//----------------------------------------------------------------------------
_P86://--STX $nn
//----------------------------------------------------------------------------
	doZ
	opSTORE m6502_x
	fetch 3
//----------------------------------------------------------------------------
_P88://--DEY
//----------------------------------------------------------------------------
	sub m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
//----------------------------------------------------------------------------
_P8A://--TXA
//----------------------------------------------------------------------------
	mov m6502_a,m6502_x
	mov m6502_nz,m6502_x,asr#24
	fetch 2
//----------------------------------------------------------------------------
_P8C://--STY $nnnn
//----------------------------------------------------------------------------
	doABS
	opSTORE m6502_y
	fetch 4
//----------------------------------------------------------------------------
_P8D://--STA $nnnn
//----------------------------------------------------------------------------
	doABS
	opSTORE m6502_a	  
	fetch 4
//----------------------------------------------------------------------------
_P8E://--STX $nnnn
//----------------------------------------------------------------------------
	doABS
	opSTORE m6502_x
	fetch 4
//----------------------------------------------------------------------------
_P90://--BCC *
//----------------------------------------------------------------------------
	tst cycles,#CYC_C			//Test Carry
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
//	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_P91://--STA ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opSTORE m6502_a
	fetch 6
//----------------------------------------------------------------------------
_P94://--STY $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_y
	fetch 4
//----------------------------------------------------------------------------
_P95://--STA $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_a
	fetch 4
//----------------------------------------------------------------------------
_P96://--STX $nn,Y
//----------------------------------------------------------------------------
	doZIYf
	opSTORE m6502_x
	fetch 4
//----------------------------------------------------------------------------
_P98://--TYA
//----------------------------------------------------------------------------
	mov m6502_a,m6502_y
	mov m6502_nz,m6502_y,asr#24
	fetch 2
//----------------------------------------------------------------------------
_P99://--STA $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opSTORE m6502_a
	fetch 5
//----------------------------------------------------------------------------
_P9A://--TXS
//----------------------------------------------------------------------------
	mov r0,m6502_x,lsr#24
	strb r0,m6502_s
	fetch 2
//----------------------------------------------------------------------------
_P9D://--STA $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opSTORE m6502_a
	fetch 5
//----------------------------------------------------------------------------
_PA0://--LDY #$nn
//----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_y
	fetch 2
//----------------------------------------------------------------------------
_PA1://--LDA ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opLOAD m6502_a
	fetch 6
//----------------------------------------------------------------------------
_PA2://--LDX #$nn
//----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_x
	fetch 2
//----------------------------------------------------------------------------
_PA4://--LDY $nn
//----------------------------------------------------------------------------
	doZ
	opLOAD m6502_y
	fetch 3
//----------------------------------------------------------------------------
_PA5://--LDA $nn
//----------------------------------------------------------------------------
	doZ
	opLOAD m6502_a
	fetch 3
//----------------------------------------------------------------------------
_PA6://--LDX $nn
//----------------------------------------------------------------------------
	doZ
	opLOAD m6502_x
	fetch 3
//----------------------------------------------------------------------------
_PA8://--TAY
//----------------------------------------------------------------------------
	mov m6502_y,m6502_a
	mov m6502_nz,m6502_y,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PA9://--LDA #$nn
//----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_a
	fetch 2
//----------------------------------------------------------------------------
_PAA://--TAX
//----------------------------------------------------------------------------
	mov m6502_x,m6502_a
	mov m6502_nz,m6502_x,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PAC://--LDY $nnnn
//----------------------------------------------------------------------------
	doABS
	opLOAD m6502_y
	fetch 4
//----------------------------------------------------------------------------
_PAD://--LDA $nnnn
//----------------------------------------------------------------------------
	doABS
	opLOAD m6502_a
	fetch 4
//----------------------------------------------------------------------------
_PAE://--LDX $nnnn
//----------------------------------------------------------------------------
	doABS
	opLOAD m6502_x
	fetch 4
//----------------------------------------------------------------------------
_PB0://--BCS *
//----------------------------------------------------------------------------
	tst cycles,#CYC_C			//Test Carry
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
//	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_PB1://--LDA ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opLOAD m6502_a
	fetch 5
//----------------------------------------------------------------------------
_PB4://--LDY $nn,X
//----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_y
	fetch 4
//----------------------------------------------------------------------------
_PB5://--LDA $nn,X
//----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_a
	fetch 4
//----------------------------------------------------------------------------
_PB6://--LDX $nn,Y
//----------------------------------------------------------------------------
	doZIY
	opLOAD m6502_x
	fetch 4
//----------------------------------------------------------------------------
_PB8://--CLV
//----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_V
	fetch 2
//----------------------------------------------------------------------------
_PB9://--LDA $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_a
	fetch 4
//----------------------------------------------------------------------------
_PBA://--TSX
//----------------------------------------------------------------------------
	ldrb m6502_x,m6502_s
	mov m6502_x,m6502_x,lsl#24
	mov m6502_nz,m6502_x,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PBC://--LDY $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_y
	fetch 4
//----------------------------------------------------------------------------
_PBD://--LDA $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_a
	fetch 4
//----------------------------------------------------------------------------
_PBE://--LDX $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_x
	fetch 4
//----------------------------------------------------------------------------
_PC0://--CPY #$nn
//----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_y
	fetch_c 2
//----------------------------------------------------------------------------
_PC1://--CMP ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opCOMP m6502_a
	fetch_c 6
//----------------------------------------------------------------------------
_PC4://--CPY $nn
//----------------------------------------------------------------------------
	doZ
	opCOMP m6502_y
	fetch_c 3
//----------------------------------------------------------------------------
_PC5://--CMP $nn
//----------------------------------------------------------------------------
	doZ
	opCOMP m6502_a
	fetch_c 3
//----------------------------------------------------------------------------
_PC6://--DEC $nn
//----------------------------------------------------------------------------
	doZ
	opDEC
	fetch 5
//----------------------------------------------------------------------------
_PC8://--INY
//----------------------------------------------------------------------------
	add m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PC9://--CMP #$nn
//----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_a
	fetch_c 2
//----------------------------------------------------------------------------
_PCA://--DEX
//----------------------------------------------------------------------------
	sub m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PCC://--CPY $nnnn
//----------------------------------------------------------------------------
	doABS
	opCOMP m6502_y
	fetch_c 4
//----------------------------------------------------------------------------
_PCD://--CMP $nnnn
//----------------------------------------------------------------------------
	doABS
	opCOMP m6502_a
	fetch_c 4
//----------------------------------------------------------------------------
_PCE://--DEC $nnnn
//----------------------------------------------------------------------------
	doABS
	opDEC
	fetch 6
//----------------------------------------------------------------------------
_PD0://--BNE *
//----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
//	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_PD1://--CMP ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opCOMP m6502_a
	fetch_c 5
//----------------------------------------------------------------------------
_PD5://--CMP $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opCOMP m6502_a
	fetch_c 4
//----------------------------------------------------------------------------
_PD6://--DEC $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opDEC
	fetch 6
//----------------------------------------------------------------------------
_PD8://--CLD
//----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_D
	fetch 2
//----------------------------------------------------------------------------
_PD9://--CMP $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opCOMP m6502_a
	fetch_c 4
//----------------------------------------------------------------------------
_PDD://--CMP $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opCOMP m6502_a
	fetch_c 4
//----------------------------------------------------------------------------
_PDE://--DEC $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opDEC
	fetch 7
//----------------------------------------------------------------------------
_PE0://--CPX #$nn
//----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_x
	fetch_c 2
//----------------------------------------------------------------------------
_PE1://--SBC ($nn,X)
//----------------------------------------------------------------------------
	doIIX
	opSBC
	fetch_c 6
//----------------------------------------------------------------------------
_PE4://--CPX $nn
//----------------------------------------------------------------------------
	doZ
	opCOMP m6502_x
	fetch_c 3
//----------------------------------------------------------------------------
_PE5://--SBC $nn
//----------------------------------------------------------------------------
	doZ
	opSBC
	fetch_c 3
//----------------------------------------------------------------------------
_PE6://--INC $nn
//----------------------------------------------------------------------------
	doZ
	opINC
	fetch 5
//----------------------------------------------------------------------------
_PE8://--INX
//----------------------------------------------------------------------------
	add m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
//----------------------------------------------------------------------------
_PE9://--SBC #$nn
//----------------------------------------------------------------------------
	doIMM
	opSBC
	fetch_c 2
//----------------------------------------------------------------------------
_PEA://--NOP
//----------------------------------------------------------------------------
	fetch 2
//----------------------------------------------------------------------------
_PEC://--CPX $nnnn
//----------------------------------------------------------------------------
	doABS
	opCOMP m6502_x
	fetch_c 4
//----------------------------------------------------------------------------
_PED://--SBC $nnnn
//----------------------------------------------------------------------------
	doABS
	opSBC
	fetch_c 4
//----------------------------------------------------------------------------
_PEE://--INC $nnnn
//----------------------------------------------------------------------------
	doABS
	opINC
	fetch 6
//----------------------------------------------------------------------------
_PF0://--BEQ *
//----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
//	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
//----------------------------------------------------------------------------
_PF1://--SBC ($nn),Y
//----------------------------------------------------------------------------
	doIIY
	opSBC
	fetch_c 5
//----------------------------------------------------------------------------
_PF5://--SBC $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opSBC
	fetch_c 4
//----------------------------------------------------------------------------
_PF6://--INC $nn,X
//----------------------------------------------------------------------------
	doZIXf
	opINC
	fetch 6
//----------------------------------------------------------------------------
_PF8://--SED
//----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_D
	fetch 2
//----------------------------------------------------------------------------
_PF9://--SBC $nnnn,Y
//----------------------------------------------------------------------------
	doAIY
	opSBC
	fetch_c 4
//----------------------------------------------------------------------------
_PFD://--SBC $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opSBC
	fetch_c 4
//----------------------------------------------------------------------------
_PFE://--INC $nnnn,X
//----------------------------------------------------------------------------
	doAIX
	opINC
	fetch 7
//***********************************************************以下指令是一些HACK游戏需要******************
_PFF://  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
//-------------------------------------------------------------------
	doAIX		//MR_AX()//
	opSBC	    //ISB()// 
                //MW_EA()//  #define	MW_EA()		WR6502(EA,DT)  // EA .... EFFECTIVE ADDRESS
	fetch 5	    //ADD_CYCLE(5)://--                               // DT .... DATA
//------------------------------------------------------------------------
_PFB://  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
//-------------------------------------------------------------------
	doAIY		//MR_AY()//
	opSBC	    //ISB()// 
                //MW_EA()//  
	fetch 5	    //ADD_CYCLE(5)://--                               
//------------------------------------------------------------------------
_P14://--   加的，不确定正确          激龟忍者传2无敌HACK需要
//-------------------------------------------------------------------
	add m6502_pc,m6502_pc,#1  //R.PC++//
	fetch 4	                  //ADD_CYCLE(4)://--                        
//-------------------------------------------------------------------
_P67:// // RRA $??                 帝国战机无敌HACK需要
//-------------------------------------------------------------------
	doZ			    //MR_ZP()// 
	opADC           //RRA()// 
					//MW_ZP()//
	fetch 5 	    //ADD_CYCLE(5)//				
//--------------------------------------------------------------------
_P03:// // SLO ($??,X)              帝国战机无敌HACK需要
//-------------------------------------------------------------------
	doIIX		//MR_IX()// 
				//SLO()// 
				//MW_EA()//
	fetch 8//	//ADD_CYCLE(8)//
//-----------------------------------------------------------------
_P07:// // SLO $??
//------------------------------------------------------------------
	doZ		    //MR_ZP()// 
				//SLO()// 
				//MW_ZP()//
	fetch 5		//ADD_CYCLE(5)//

//----------------------------------------------------------------------------
.extern debug_6502  //main.c
_Pxx://	???					//invalid opcode	无效的操作码
//----------------------------------------------------------------------------
	//mov r1,#1           //不用debug可以直接注译这两行
    //bl debug_6502 TODO:
	
	fetch 2

//***************************************************************************************************

.text
//	THUMB
//   PRESERVE8 
//----------------------------------------------------------------------------
.global cpu6502_interface_init
.type cpu6502_interface_init, %function
.align 8
cpu6502_interface_init:
	stmfd sp!,{r4-r11,lr}
	mov r4, r0
	ldr r5, = mapper_write
	add r5,r5,r4
	str r1, [r5]
	ldr r5, = mapper_readlow
	add r5,r5,r4
	str r2, [r5]
	ldr r5, = mapper_writelow
	add r5,r5,r4
	str r3, [r5]
	ldmfd sp!,{r4-r11,lr}
	bx lr
//----------------------------------------------------------------------------
.global cpu6502_init
.type cpu6502_init, %function
.align 8
cpu6502_init:
//----------------------------------------------------------------------------
	stmfd sp!,{r4-r11,lr}
	mov r4, r0// ram offset
	ldr r3, = sys_r9
	add r3,r3,r4
	str r9, [r3]
	ldr r3, = ppu_write
	add r3,r3,r4
	str r1, [r3]
	ldr r3, = ppu_read
	add r3,r3,r4
	str r2, [r3]
    ldr r10,=cpu_data	//读取地址
	add r10,r10,r4
	ldr r11,=NES_RAM	//r11=cpu_zpage
	add r11,r11,r4
	
	ldr r11,[r11]       //NES_RAM用了指针 
//*******************************************************		
	str r11,memmap_tbl             //NES_RAM用了指针
	str r11,memmap_tbl_4
	str r11,memmap_tbl_8

	ldr r0,=NES_SRAM              //NES_SRAM用了指针
	add r0,r0,r4
	ldr r0,[r0]
	str r0,memmap_tbl_12
//**********************************************************************			

	ldr r0,=romfile		
	add r0,r0,r4 
	ldr r0,[r0]			 //R0现在指向ROM映像（包括头）
	add r3,r0,#16		//r3现在指向rom镜像(不包括头）
	str r3,rombase		//设置rom基地址
						//r3=rombase til end of loadcart so DON'T FUCK IT UP
	mov r2,#1
	ldrb r1,[r3,#-12]	// 16kB PROM的数目  	 2
	rsb r0,r2,r1,lsl#14	 //romsize=X*16KB	 <<14 逆向减法指令	 r0=0x7fff
	str r0,rommask		//rommask=promsize-1	 32768-1	
//------------------------------------------------------------------------------------	
	mov r9,#0		//(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		//6502PC从 ROM的最后偏移量写0

	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	str r9, [r2]

	mov r0,#0			//默认rom映射
	bl map89AB_			//89AB=1st 16k
	mov r0,#-1
	bl mapCDEF_			//CDEF=last 16k
		
//------------------------------------------------------------------------------
    ldrb r1,[r3,#-10]		//get mapper#
	ldrb r2,[r3,#-9]
	tst r2,#0x0e			//long live DiskDude!
	and r1,r1,#0xf0
	and r2,r2,#0xf0
	orr r0,r2,r1,lsr#4
	movne r0,r1,lsr#4		//ignore high nibble if header looks bad	忽略高四位，如果头看起来很糟糕
                            //r0=mapper号
//--------------------------------------------------------------------------------	
		
	adr r0,Mapper_W           //保存处理mapper的函数地址
	str r0,writemem_tbl_16
	str r0,writemem_tbl_20
	str r0,writemem_tbl_24
	str r0,writemem_tbl_28

//-------------------------------------------------------------------------------
	bl CPU_reset		//reset everything else
	ldmfd sp!,{r4-r11,lr}
	bx lr

.global map67_0
.type map67_0, %function
.align 4
//----------------------------------------------------------------------------
map67_0:	//mapper3 r0=page# //6502.s俄罗斯方块需要
//----------------------------------------------------------------------------
	push {r4,r9}

	ldr r10,=cpu_data	//读取地址
	add r10,r10,r4
	mov r9,#0		//(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		//6502PC从 ROM的最后偏移量写0
	ldr r1,rommask
	and r0,r1,r0,lsl#13
	ldr r1,rombase
	add r0,r1,r0
	sub r0,r0,#0x6000
	str r0,memmap_tbl_12
	b flush

.global map67_
.type map67_, %function
.align 4	
map67_:	
	push {r4,r9}
	mov r4,r1
	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	ldr r9, [r2]

	ldr r1,rommask
	and r0,r1,r0,lsl#13
	ldr r1,rombase
	add r0,r1,r0
	sub r0,r0,#0x6000
	str r0,memmap_tbl_12
	b flush
//----------------------------------------------------------------------------
.global map89_
.type map89_, %function
.align 4
map89_:	//rom paging.. r0=page# ROM分页
//----------------------------------------------------------------------------
	push {r4,r9}
	mov r4,r1
	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	ldr r9, [r2]

	ldr r1,rombase			 //rom开始地址
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl_16
	b flush
//----------------------------------------------------------------------------
.global mapAB_
.type mapAB_, %function
.align 4
mapAB_:
//----------------------------------------------------------------------------
	push {r4,r9}
	mov r4,r1
	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	ldr r9, [r2]

	ldr r1,rombase
	sub r1,r1,#0xa000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl_20
	b flush
//----------------------------------------------------------------------------
.global mapCD_
.type mapCD_, %function
.align 4
mapCD_:
//----------------------------------------------------------------------------
	push {r4,r9}
	mov r4,r1
	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	ldr r9, [r2]

	ldr r1,rombase
	sub r1,r1,#0xc000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl_24
	b flush
//----------------------------------------------------------------------------
.global mapEF_
.type mapEF_, %function
.align 4
mapEF_:
//----------------------------------------------------------------------------
	push {r4,r9}
	mov r4,r1
	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	ldr r9, [r2]

	ldr r1,rombase
	sub r1,r1,#0xe000
	ldr r2,rommask
	and r0,r2,r0,lsl#13
	add r0,r1,r0
	str r0,memmap_tbl_28
	b flush
//----------------------------------------------------------------------------
.global map89AB_
.type map89AB_, %function
.align 4
map89AB_:
//----------------------------------------------------------------------------
	push {r4,r9}
	
	ldr r1,rombase		   //rom基地址（不包括头）
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#14
	add r0,r1,r0
	str r0,memmap_tbl_16
	str r0,memmap_tbl_20
flush:		//update m6502_pc & lastbank
	ldr r1,lastbank
	sub r9,r9,r1
	and r1,r9,#0xE000	   ////r9和0xe000按位与运算
	@ adr r2,memmap_tbl		   ////把存储器映象地址加载到r2
	mov r2,globalptr
	add r2,r2,#(4+32+32)

	lsr r1,r1,#11				////>>11位	  r1/2048
	ldr r0,[r2,r1]				////读取r2地址+r1偏移的数据到r0

	str r0,lastbank				////保存6502PC从 ROM的最后偏移量 
	add r9,r9,r0	////m6502_pc+r0

	ldr r2, =pc6502_p //恢复上次
	add r2, r2, r4
	str r9, [r2]
	
	pop {r4,r9}
	orr lr,#0x01		//lr最低位置1防止进入arm状态
	bx lr

//----------------------------------------------------------------------------
.global mapCDEF_
.type mapCDEF_, %function
.align 4
mapCDEF_:
//----------------------------------------------------------------------------
	push {r4,r9}
	
	ldr r1,rombase
	sub r1,r1,#0xc000
	ldr r2,rommask
	and r0,r2,r0,lsl#14
	add r0,r1,r0
	str r0,memmap_tbl_24
	str r0,memmap_tbl_28
	b flush
//----------------------------------------------------------------------------
.global map89ABCDEF_
.type map89ABCDEF_, %function
.align 4
map89ABCDEF_:           //mapper9
//----------------------------------------------------------------------------
	push {r4,r9}
	
	ldr r10,=cpu_data	//读取地址
	add r10,r10,r4
	mov r9,#0		//(消除任何encodePC的映射器*初始化过程中的错误)
	str r9,lastbank		//6502PC从 ROM的最后偏移量写0
	
	ldr r1,rombase
	sub r1,r1,#0x8000
	ldr r2,rommask
	and r0,r2,r0,lsl#15
	add r0,r1,r0
	str r0,memmap_tbl_16
	str r0,memmap_tbl_20
	str r0,memmap_tbl_24
	str r0,memmap_tbl_28
	b flush
	
//*************************************************************************************
@ .extern asm_Mapper_Write //
Mapper_W:	
//-------------------------------------------
	stmfd sp!,{r2-r3,lr}	//LR 寄存器放栈
	mov r1,r12

	ldr r2, = pc6502_p //保存当前的r9
	add r2, r2, r4
	str r9, [r2]

	@ bl asm_Mapper_Write
	ldr r2, = sys_r9 //更新r9
	add r2, r2, r4
	ldr r9, [r2]

	ldr r2, = mapper_write
	add r2, r2, r4
	ldr r2, [r2]
	blx r2

	ldr r2, = pc6502_p //restore当前的r9
	add r2, r2, r4
	ldr r9, [r2]

	ldmfd sp!,{r2-r3,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态
	bx lr
	nop
//---------------------------------------------------------------------------------------

//*****************************************************************************************************
.text
//	THUMB
//   PRESERVE8 
	
//----------------------------------------------------------------------------
.global run6502
.type run6502, %function
.align 8
run6502://r0=要运行的cpu周期*256
//----------------------------------------------------------------------------
	
	stmfd sp!,{r4-r11,lr}		//将这几个寄存器中的值保存到堆栈中
	mov r2, r1
	ldr globalptr,=cpu_data	 //r10   wram_globals: 读取地址
	add globalptr,globalptr,r2
	ldr cpu_zpage,=NES_RAM			   	//r11
	add cpu_zpage,cpu_zpage,r2
    ldr cpu_zpage,[cpu_zpage]       //NES_RAM用了指针
 
	@ adr r1,cpuregs
	mov r1,globalptr
	add r1,r1,#(4+32+32+32)


	ldmia r1,{m6502_nz-m6502_pc}	//restore 6502 state恢复6502状态	 r3-r9
	mov ram_offset,	r2
	add cycles,cycles,r0	
			
	ldrb r0,cpuirqf //cpu中断标志
	cmp r0,#0x01//
	beq CheckI      //EQ       相等(EQual)	irq6502//

	fetch 0       ////提取操作码并运行							   
exit_run:

    ldrb r0,cpunmif //cpu中断标志
	cmp r0,#0x01//
	beq NMI6502      //EQ       相等(EQual)	
	
exit_nmi:	
	@ adr r0,cpuregs
	mov r0,globalptr
	add r0,r0,#(4+32+32+32)

	stmia r0,{m6502_nz-m6502_pc} //保存6502状态	  r3-r9
	
	ldmfd sp!,{r4-r11,pc}	//exit 					
    
//***************************************************************************************
.global NMI6502
.type NMI6502, %function
.align 4
NMI6502: //---------------------------
    mov r0,#0
	str r0,cpunmif//清除cpu中断标志   

	ldr r12,=NMI_VECTOR		 //NMI?	 addy
	bl Vec6502
	sub cycles,cycles,#7*256	//CYCLE=256	 6502的中断潜伏期为七 (7) 个周
                              // 期// 这也就是说需要需要七 (7) 个周期来移入和移出一个中断
    b exit_nmi		//return 
//----------------------------------------------------------------------------

default_scanlinehook:
   
	fetch 0
//----------------------------------------------------------
CheckI:								//Check Interrupt Disable 检查中断禁用
//----------------------------------------------------------
	tst cycles,#CYC_I
	bne default_scanlinehook		//we dont want no stinkin irqs 我们不需要没有讨厌的IRQ
//----------------------------------------------------------
irq6502: 
//----------------------------------------------------------
	mov r0,#0
	str r0,cpuirqf//清除cpu中断标志
	
	ldr r12,=IRQ_VECTOR
	bl Vec6502
	fetch 7    
//----------------------------------------------------------
Vec6502:
//----------------------------------------------------------
	ldr r0,lastbank
	sub r0,m6502_pc,r0
	push16					//save PC

	encodeP (R)				//save P
VecCont:
	push8 r0

	orr cycles,cycles,#CYC_I	//disable IRQ	禁用IRQ

	ldr r0,memmap_tbl_28	  //7*4
//	ldrb m6502_pc,[r0,r12]!
	ldrb m6502_pc,[r0,r12]	//在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            //若使用后缀"!",则结果写回到Rn中
	add r0,r0,r12			 //R12=0xfffc //// 复位中断向量地址
	
	ldrb r2,[r0,#1]
	orr m6502_pc,m6502_pc,r2,lsl#8
	encodePC				//get IRQ vector得到6502 PC ROM的偏移量

	bx lr					  // 函数返回
//----------------------------------------------------------------------------
.global CPU_reset
.type CPU_reset, %function
.align 4
CPU_reset:	//called by loadcart (r0-r9 are free to use)
//----------------------------------------------------------------------------
	str lr,[sp,#-4]!	
	
	mov m6502_a,#0
	mov m6502_x,#0
	mov m6502_y,#0
	mov m6502_nz,#0

	@ adr m6502_rmem,readmem_tbl //把readmem_tbl的地址加载到m6502_rmem
	@ mov m6502_rmem,globalptr
	@ add m6502_rmem,m6502_rmem,#(4)


//	ldr r0,=NES_RAM+0x100	   //256	
		  ldr r0,=NES_RAM            //NES_RAM用了指针
		  add r0,r0,r4
		  ldr r0,[r0]                //
		  add r0,#0x100
  
	str r0,m6502_s		//S=0xFD (0x100-3)	  把一个寄存器按字存储到存储器中
//-------------------------------------------------------	
	mov r0,#0
	str r0,cpunmif  //清除cpu中断标志
	str r0,cpuirqf  //清除cpu中断标志
//------------------------------------------	
	mov cycles,#0		//D=0, C=0, V=0, I=1 disable IRQ.

	ldr r12,=RES_VECTOR		 //// 复位中断向量地址
	bl Vec6502

	@ adr r0,cpuregs			 //读取地址
	mov r0,globalptr
	add r0,r0,#(4+32+32+32)

	stmia r0,{m6502_nz-m6502_pc}	   //保存6502状态

	adr r1,exit_run				  //
	str r1,nexttimeout		  //保存指令执行完后下一步的PC地址

	ldr r1,[sp],#4
	orr r1,r1,#0x1
	bx r1
//	nop
//-------------------------------------------------------------------------

.text //READWRITE**************************************
.align 4
//----------------------------------------------------------------------------
//memory
//------------------------------------------------------------------------
empty_R:		//读地址不正确read bad address (error)
//----------------------------------------------------------------------------	
	mov r0,r12
	mov r1,#2
    bl debug_6502
	//----------------------------------
	mov r0,#0
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr  
//----------------------------------------------------------------------------

.type void, %function
.align 4
void: //- - - - - - - - -空函数
	mov r0,#0	
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr

//----------------------------------------------------------------------------
ram_R:	//ram read ($0000-$1FFF)
//----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		//only 0x07FF is RAM
	ldrb r0,[cpu_zpage,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
ram_W:	//ram write ($0000-$1FFF)
//----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		//only 0x07FF is RAM
	strb r0,[cpu_zpage,addy]   // cpu_zpage	RN r11 //=CPU_RAM
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
sram_R:	//sram read ($6000-$7FFF)
//----------------------------------------------------------------------------
	sub r1,addy,#0x6000	
    ldr r2,memmap_tbl_12 
//	ldrb r0,[cpu_zpage,r1]
	ldrb r0,[r2,r1]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
sram_W:	//sram write ($6000-$7FFF)
//----------------------------------------------------------------------------
	sub addy,addy,#0x6000
    ldr r1,memmap_tbl_12                     
//	strb r0,[cpu_zpage,addy]
	strb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
rom_R60:	//rom read ($6000-$7FFF)
//----------------------------------------------------------------------------
	ldr r1,memmap_tbl_12
	ldrb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
rom_R80:	//rom read ($8000-$9FFF)
//----------------------------------------------------------------------------
	ldr r1,memmap_tbl_16
	ldrb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
rom_RA0:	//rom read ($A000-$BFFF)
//----------------------------------------------------------------------------
	ldr r1,memmap_tbl_20
	ldrb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
rom_RC0:	//rom read ($C000-$DFFF)
//----------------------------------------------------------------------------
	ldr r1,memmap_tbl_24
	ldrb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
rom_RE0:	//rom read ($E000-$FFFF)
//----------------------------------------------------------------------------
	ldr r1,memmap_tbl_28
	ldrb r0,[r1,addy]
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr

	nop
//----------------------------------------------------------------------------
//IO
.text //--
.align 4
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
IO_R:		//I/O read
//----------------------------------------------------------------------------
	//mov r2,#0x4018      //$4018-$6000 //invalid constant (4018) after fixup 超出范围了，分成两个指令  --By VeiLiang 
	mov r2,#0x4000
	add r2,#0x18
	cmp r12,r2    	
	bhi  Read_Low              //HI  无符号数大于  C==1 && Z==0 
		
	sub r1,r12,#0x4000	 //addy=r12
	subs r1,r1,#0x15
	bmi empty_R		  //读地址不正确 MI       负数(MInus)                   N==1 
	cmp r1,#3
//	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_read_tbl   ////改过，加3行
	add r2,r2,r4
	add r2,r2,r1,lsl#2			  //<<2
	ldrmi r1,[r2]
	orr r1,r1,#0x1
	bx r1
	b empty_R          //读地址不正确
//	nop
.data 
.align 8
io_read_tbl:
	.long apu_4015R//void//_4015r	//4015 (sound)
	.long joy0_R	//4016: controller 1
	.long joy1_R	//4017: controller 2
.text //--
.align 4
//----------------------------------------------------------------------------
IO_W:		//I/O write
//----------------------------------------------------------------------------
	//mov r2,#0x4018      //$4018-$6000 //invalid constant (4018) after fixup 超出范围了，分成两个指令  --By VeiLiang 
	mov r2,#0x4000
	add r2,#0x18
	cmp r12,r2    	
	bhi  Write_Low              //HI  无符号数大于  C==1 && Z==0 
	
	sub r1,r12,#0x4000	   //addy=r12
	cmp r1,#0x18
//	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_write_tbl   ////改过，加3行
	add r2,r2,r4
	add r2,r2,r1,lsl#2			  //<<2		
	ldrmi r1,[r2]          ////直接操作pc太他妈危险了
	orr r1,r1,#0x1
	bx r1
	b empty_R		  //读地址不正确
 	nop
.data 
.align 8
io_write_tbl:	
	.long apu_w//void//_4000w
	.long apu_w//_4001w
	.long apu_w//_4002w
	.long apu_w//_4003w
	.long apu_w//_4004w
	.long apu_w//_4005w
	.long apu_w//_4006w
	.long apu_w//_4007w
	.long apu_w//_4008w
	.long apu_w//void//
	.long apu_w//_400aw
	.long apu_w//void//_400bw
	.long apu_w//void//_400cw
	.long apu_w//void
	.long apu_w//void//_400ew
	.long apu_w//void//_400fw
	.long apu_w//void//_4010w
	.long apu_w//void//_4011w
	.long apu_w//void//_4012w
	.long apu_w//void//_4013w
	.long dma_W	//$4014: Sprite DMA transfer
	.long apu_4015w//void//_4015w		 // 声音通道切换 

	.long joy0_W	//$4016: Joypad 0 write//joypad_write_ptr
	.long apu_4017w//void//$4017: ?
.text //--
.align 4	
//-------------------------------------------------------------------------------
@ .extern asm_Mapper_ReadLow
.global Read_Low
.type Read_Low, %function
.align 4
Read_Low://$5000-$6000  mapper->MemoryReadLow(addr)//	
//------------------------------------------------------------------------------
    stmfd sp!,{r2-r3,lr}	//LR 寄存器放栈 
	mov r0,r12

	ldr r2, = pc6502_p //保存当前的r9
	add r2, r2, r4
	str r9, [r2]
	
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = mapper_readlow
	add r2, r2, r4
	ldr r2, [r2]
	blx r2

	ldr r2, = pc6502_p //restore当前的r9
	add r2, r2, r4
	ldr r9, [r2]
	ldmfd sp!,{r2-r3,lr}

	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr

//-------------------------------------------------------------------------------
@ .extern asm_Mapper_WriteLow
.global Write_Low
.type Write_Low, %function
.align 4
Write_Low: //$5000-$6000  mapper->MemoryWriteLow( data, addr)//	
//------------------------------------------------------------------------------
    stmfd sp!,{r2-r3,lr}	//LR 寄存器放栈 
	mov r1,r12
	@ bl asm_Mapper_WriteLow
	ldr r2, = pc6502_p //保存当前的r9
	add r2, r2, r4
	str r9, [r2]

	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]

	ldr r2, = mapper_writelow
	add r2, r2, r4
	ldr r2, [r2]
	blx r2

	ldr r2, = pc6502_p //restore当前的r9
	add r2, r2, r4
	ldr r9, [r2]
	ldmfd sp!,{r2-r3,lr}

	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr

.global apu_func_init
.type apu_func_init, %function
.align 4
apu_func_init:
	stmfd sp!,{r4-r11,lr}
	mov r4, r0
	ldr r5, = apu_write
	add r5,r5,r4
	str r1, [r5]
	ldr r5, = apu_write4015
	add r5,r5,r4
	str r2, [r5]
	ldr r5, = apu_write4017
	add r5,r5,r4
	str r3, [r5]
	ldmfd sp!,{r4-r11,lr}
	bx lr
.global apu_func_init2
.type apu_func_init2, %function
.align 4
apu_func_init2:
	stmfd sp!,{r4-r11,lr}
	mov r4, r0
	ldr r5, = apu_read4015
	add r5,r5,r4
	str r1, [r5]
	ldmfd sp!,{r4-r11,lr}
	bx lr

//-----------------------------------------------------------------------------
	@ .extern Apu_Write  //apu.c 
	@ .extern Apu_Write4015  //apu.c	
//-----------------------------------------------------------------------------------
apu_w:					// 0x4000--0x4013
//---------------------------------------------------------------------------------
    stmfd sp!,{r2,r3,r9,lr}	//LR 寄存器放栈 
	@ bl Apu_Write
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = apu_write
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2,r3,r9,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//-----------------------------------------------------------------------------------
apu_4015w:
//-------------------------------------------------------------------------
	stmfd sp!,{r2,r3,r9,lr}	//LR 寄存器放栈      
	//bl Apu_Write4015 TODO: not support apu.
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = apu_write4015
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2,r3,r9,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//-----------------------------------------------------------------------------------
	@ .extern Apu_Write4017  //apu.c
apu_4017w:
//-------------------------------------------------------------------------
	stmfd sp!,{r2,r3,r9,lr}	//LR 寄存器放栈      
	//bl Apu_Write4017 TODO: not support apu.
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = apu_write4017
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2,r3,r9,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
    @ .extern Apu_Read4015  //apu.c
apu_4015R:	//4015
//----------------------------------------------------------------------------------	
	stmfd sp!,{r2,r3,r9,lr}	//LR 寄存器放栈 
	add r0,r1,#0x15
	@ bl Apu_Read4015 TODO:
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = apu_read4015
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2,r3,r9,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
dma_W:	//(4014)		sprite DMA transfer	精灵DMA传输	DMA访问精灵RAM：
//通过写一个值xx到这个端口，引起CPU内存地址为$xx00－$xxFF的区域传送到精灵内存 
//----------------------------------------------------------------------------
	sub cycles,cycles,#512*256
	stmfd sp!,{r3,lr}

	and r1,r0,#0xe0
	@ adr r2,memmap_tbl  //CPU_RAM
	mov r2,globalptr
	add r2,r2,#(4+32+32)

	lsr r1,r1,#3       //>>3
	ldr r2,[r2,r1]
	and r0,r0,#0xff
	add r2,r2,r0,lsl#8	//addy  r2=DMA source 源
	ldr r1,=spr_ram		//r1     DMA的 目的地	   ppu.c
	add r1,r1,r4
	ldr r1,[r1]         //spr_ram用了指针
		
	mov r0,#64			//256/4
copy_:
	subs r0,r0,#1		  //-1
	ldr r3,[r2,r0,lsl#2]
	str r3,[r1,r0,lsl#2]  //<<2	   *4
	bne copy_              //r0!=0

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
    bx lr
//----------------------------------------------------------------------------
    .extern PADdata0
	.extern PADdata1	
joy0_W:		//4016  手柄1键值 [7:0]右7 左6 下5 上4 Start3 Select2 B1 A0   )
//----------------------------------------------------------------------------
	tst r0,#1           //0＝写，1＝读
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bxne lr            //NE       不等（NotEqual）  
	
	ldr r1,=PADdata0//--//手柄1键值  
	add r1, r1, r4
    ldr r1,[r1]
	str r1,joy0data
	          	
	ldr r1,=PADdata1//--//手柄1键值  
	add r1, r1, r4
    ldr r1,[r1]
	str r1,joy1data							
				
	bx lr
//----------------------------------------------------------------------------
joy0_R:		//4016
//----------------------------------------------------------------------------	
	ldr r0,joy0data	   //串行数据  当前读取位//joy0data是键值
    mov r1,r0,lsr#1       //>>1
	str r1,joy0data
	
	and r0,r0,#1      //&1	
	orr r0,r0,#0x40   //|0x40

    orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//----------------------------------------------------------------------------
joy1_R:		//4017
//----------------------------------------------------------------------------
	ldr r0,joy1data	   //串行数据  当前读取位//joy0data是键值
    mov r1,r0,lsr#1       //>>1
	str r1,joy1data
	
	and r0,r0,#1      //&1	
	orr r0,r0,#0x40   
	
    orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//--------------------------------------------------------------
.global K6502_Read
.type K6502_Read, %function
.align 4
K6502_Read://apu  Rendering DPCM channel #5		r0=APU->ApuC5Address不确定正确*
//---------------------------------------------------------------
	   //EXPORT  K6502_Read		//switch ( wAddr & 0xe000 ) apu.c
    stmfd sp!,{lr}
	
	mov r1,r0,lsr#13 //>>13=  & 0xe000
	ldr r2,=CPU_RAM//////存储器映象 ram+rom	
	ldr r1,[r2,r1,lsl#2]	//lookup rom ptr..查找ptr
	
    bic r0,r0,#0xe000 //and r0,#0x1fff &0x1fff	
	ldrb r0,[r1,r0]
	
    ldmfd sp!,{lr}
	bx lr
//	nop
//------------------------------------------------------------------------
.text
.align 4
//------------------------------------------------------------------------------------
PPU_W:
	stmfd sp!,{r2-r3,r9, lr}	//LR 寄存器放栈 
	mov r1,r12
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = ppu_write
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2-r3, r9, lr}
	orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
//--------------------------------------------------------------------------------------
PPU_R:
	stmfd sp!,{r2-r3,r9,lr}	//LR 寄存器放栈    会改变R4 
	mov r0,r12
	ldr r2, = sys_r9
	add r2, r2, r4
	ldr r9, [r2]
	ldr r2, = ppu_read	
	add r2, r2, r4
	ldr r2, [r2]
	blx r2
	ldmfd sp!,{r2-r3,r9,lr}
    orr lr,#0x01		//lr最低位置1防止进入arm状态 //F1C100s 本来就是arm状态，需要注释掉这个指令 --By VeiLiang 
	bx lr
    nop
//-----------------------------------------------------------------------------------------
.data 
.align 8
//-----------------------------------------------------------------------------------------		
op_table:	   //.long 用于分配一段字内存单元 op_table内存块起始地址标号
	.long _P00,_P01,_Pxx,_P03,_Pxx,_P05,_P06,_P07,_P08,_P09,_P0A,_Pxx,_Pxx,_P0D,_P0E,_Pxx
	.long _P10,_P11,_Pxx,_Pxx,_P14,_P15,_P16,_Pxx,_P18,_P19,_Pxx,_Pxx,_Pxx,_P1D,_P1E,_Pxx
	.long _P20,_P21,_Pxx,_Pxx,_P24,_P25,_P26,_Pxx,_P28,_P29,_P2A,_Pxx,_P2C,_P2D,_P2E,_Pxx
	.long _P30,_P31,_Pxx,_Pxx,_Pxx,_P35,_P36,_Pxx,_P38,_P39,_Pxx,_Pxx,_Pxx,_P3D,_P3E,_Pxx
	.long _P40,_P41,_Pxx,_Pxx,_Pxx,_P45,_P46,_Pxx,_P48,_P49,_P4A,_Pxx,_P4C,_P4D,_P4E,_Pxx
	.long _P50,_P51,_Pxx,_Pxx,_Pxx,_P55,_P56,_Pxx,_P58,_P59,_Pxx,_Pxx,_Pxx,_P5D,_P5E,_Pxx
	.long _P60,_P61,_Pxx,_Pxx,_Pxx,_P65,_P66,_P67,_P68,_P69,_P6A,_Pxx,_P6C,_P6D,_P6E,_Pxx
	.long _P70,_P71,_Pxx,_Pxx,_Pxx,_P75,_P76,_Pxx,_P78,_P79,_Pxx,_Pxx,_Pxx,_P7D,_P7E,_Pxx
	.long _Pxx,_P81,_Pxx,_Pxx,_P84,_P85,_P86,_Pxx,_P88,_Pxx,_P8A,_Pxx,_P8C,_P8D,_P8E,_Pxx
	.long _P90,_P91,_Pxx,_Pxx,_P94,_P95,_P96,_Pxx,_P98,_P99,_P9A,_Pxx,_Pxx,_P9D,_Pxx,_Pxx
	.long _PA0,_PA1,_PA2,_Pxx,_PA4,_PA5,_PA6,_Pxx,_PA8,_PA9,_PAA,_Pxx,_PAC,_PAD,_PAE,_Pxx
	.long _PB0,_PB1,_Pxx,_Pxx,_PB4,_PB5,_PB6,_Pxx,_PB8,_PB9,_PBA,_Pxx,_PBC,_PBD,_PBE,_Pxx
	.long _PC0,_PC1,_Pxx,_Pxx,_PC4,_PC5,_PC6,_Pxx,_PC8,_PC9,_PCA,_Pxx,_PCC,_PCD,_PCE,_Pxx
	.long _PD0,_PD1,_Pxx,_Pxx,_Pxx,_PD5,_PD6,_Pxx,_PD8,_PD9,_Pxx,_Pxx,_Pxx,_PDD,_PDE,_Pxx
	.long _PE0,_PE1,_Pxx,_Pxx,_PE4,_PE5,_PE6,_Pxx,_PE8,_PE9,_PEA,_Pxx,_PEC,_PED,_PEE,_Pxx
	.long _PF0,_PF1,_Pxx,_Pxx,_Pxx,_PF5,_PF6,_Pxx,_PF8,_PF9,_Pxx,_PFB,_Pxx,_PFD,_PFE,_PFF
		                                                         
//---------------------------------------------------------------------------------				
.data
.align 8
//---------------------------------------------------------------------------------		
cpu_data:        //43*4
	.long op_table        //opz #   4      //代码表地址	
  //readmem_tbl													
	.long ram_R	//$0000				
	.long PPU_R	//$2000
	.long IO_R	//$4000
	.long sram_R	//$6000
	.long rom_R80	//$8000
	.long rom_RA0	//$A000
	.long rom_RC0	//$C000
	.long rom_RE0	//$E000
  //writemem_tbl
	.long ram_W	//$0000			  
	.long PPU_W	//$2000	  r0传参数
	.long IO_W	//$4000
	.long sram_W	//$6000
	.long void	//$8000
	.long void	//$A000
	.long void	//$C000
	.long void	//$E000
CPU_RAM:   //memmap_tbl		存储器映象
	.long NES_RAM		//$0000   0000-7fff	 keep $400 byte aligned for 6502 stack shit
	.long NES_RAM		//$2000    should应该	  保持1024字节对齐
	.long NES_RAM		//$4000     never从来没有
	.long NES_SRAM //--NES_RAM-0x5800	//$6000      change改变
rommap:	.fill 4*4			//$8000-FFFF	 memmap_tbl+16

cpustate:
	//group these together for save/loadstate
	.fill 7*4 //cpuregs (nz,c,a,x,y,cycles,pc)
	.long 0 //m6502_s:
	.long 0 //lastbank: 最后MEMMAP添加到PC （用于计算当前的PC ）
	.long exit_run //nexttimeout:  jump here when cycles runs out	跳到下一个时钟周期运行
   
    .long 0   //rombase # 4			////ROM开始地址
    .long 0   //romnumber # 4		 //// 
    .long 0   //rommask # 4		   ////ROM掩膜	rommask=romsize-1
		
	.long 0   //joy0data # 4	   ////手柄1串行数据
	.long 0   //joy1data # 4	   ////手柄2串行数据	
clocks:		
	.long 0	//clocksh # 4    ////执行的时钟数 apu用
cpunmi:
    .long 0   //cpunmif # 4      //cpu中断标志
cpuirq:
    .long 0   //cpuirqf # 4      //cpu中断标志 		
ppu_write:
	.long 0
ppu_read:
	.long 0
sys_r9:
	.long 0
mapper_write:
	.long 0
mapper_readlow:
	.long 0
mapper_writelow:
	.long 0
apu_write:
	.long 0
apu_write4015:
	.long 0
apu_write4017:
	.long 0
apu_read4015:
	.long 0
pc6502_p:
	.long 0
//	DCW 0	DCW定义16位变量
//----------------------------------------------------------------------------
//	ALIGN           //通过用零或空指令NOP填充，来使当前位置与一个指定的边界对齐
.align 8
.end



//align 4
//***************************************************************************************************
//***************************************************************************************************

	//INCLUDE equates.h

	//IMPORT void  //6502s
	//IMPORT spr_ram		 //ppu.c
	
	//EXPORT nes_palette	   //NES $3F00-$3F1F   NES调色板
	//EXPORT PPU_scanline

	//EXPORT nes_nt0
	//EXPORT nes_nt1
	//EXPORT nes_nt2
	//EXPORT nes_nt3

	//EXPORT PPU_BG_HScrlOrg
	//EXPORT PPU_BG_VScrlOrg
	//EXPORT PPU_Latch_Flag  // 背景位移￥2005写入标志
	//EXPORT PPU_R0//
	//EXPORT PPU_R1//
	//EXPORT PPU_R2//
	//EXPORT PPU_R5//
	//EXPORT PPU_addrcnt
    //EXPORT PPU_readtemp// 		//读取操作缓冲
	//EXPORT spr_addrcnt  		//spraddrcnt  sprite 地址计数器	  u8

	//EXPORT PPU_R//			   读PPU寄存器
	//EXPORT PPU_W

	

 //AREA ppu_code, CODE, READONLY
	//PRESERVE8

//addy        RN  r12 //

////----------------------------------------------------------------------------
//PPU_R//			   读PPU寄存器
////----------------------------------------------------------------------------
	//and r0,addy,#7
////	ldr pc,[pc,r0,lsl#2]  ////加3行

////	ldr r1,=PPU_read_tbl   
////	add r1,r1,r0,lsl#2			  //<<2			
////	ldr pc,[r1]			   ////直接操作pc太他妈危险了
////	nop

	//tbh     [pc,r0,lsl #1]
//PPU_read_tbl
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2000
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2001
	//DCI (stat_R-PPU_read_tbl)/2		//$2002
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2003
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2004
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2005
	//DCI (empty_PPU_R-PPU_read_tbl)/2	//$2006
	//DCI (vmdata_R-PPU_read_tbl)/2	//$2007


////PPU_read_tbl
////	DCD empty_PPU_R	//$2000
////	DCD empty_PPU_R	//$2001
////	DCD stat_R		//$2002
////	DCD empty_PPU_R	//$2003
////	DCD empty_PPU_R	//$2004
////	DCD empty_PPU_R	//$2005
////	DCD empty_PPU_R	//$2006
////	DCD vmdata_R	//$2007
////----------------------------------------------------------------------------
//PPU_W//
////----------------------------------------------------------------------------
	//and r1,addy,#7
////	ldr pc,[pc,r2,lsl#2]  ////改过，加3行

	//ldr r2,=PPU_write_tbl   
	//add r2,r2,r1,lsl#2			  //<<2			
	//ldr pc,[r2]
	//nop
			
//PPU_write_tbl
	//DCD ctrl0_W		//$2000
	//DCD ctrl1_W		//$2001
	//DCD void		//$2002
	//DCD ppu2003_W	//$2003
	//DCD ppu2004_W	//$2004	
	//DCD bgscroll_W	//$2005
	//DCD vmaddr_W	//$2006
	//DCD vmdata_W	//$2007

////----------------------------------------------------------------------------
//empty_PPU_R
////----------------------------------------------------------------------------
	//mov r0,#0
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr

////----------------------------------------------------------------------------
//stat_R		//(2002)		  读PPU寄存器
////----------------------------------------------------------------------------
	//mov r0,#0
	//strb r0,toggle		 //PPU_Latch_Flag = 0//		  //背景位移￥2005写入标志
	//ldrb r0,ppur2	   //temp = PPU_R2	   	 
	//and r2,r0,#0x7f		 //PPU_R2 &= 0x7f//
	//strb r2,ppur2
	
	//ldr r1,scanline		// 扫描线   if ((PPU_scanline > 20 && PPU_scanline < 262) && !(PPU_R0 & 0x80))					 
	//cmp r1,#20			//比较  If R1>20 Then （T代表Then，E代表Else）
	//bhi r_2002
	
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr
//r_2002
	//ldrb r1,ppur0		//!(PPU_R0 & 0x80))
	//tst r1,#0x80
	//ldrb r1,ppur0
	//andeq r1,r1,#0xfc		//	!PPU_R0 &= 0xfc//											
	//strb r1,ppur0		 // ppu寄存器

	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr
////-------------------------------------------------------------------------------------------
////----------------------------------------------------------------------------
//vmdata_R	//(2007)	  ppu_R		  ////读PPU存储器	  要读ppu存储器的值r0返回
////----------------------------------------------------------------------------	   													
	//ldr r0,addrcnt		// //保存缓冲值，作为返回值
	//cmp r0,#0x3f00		//if(PPU_addrcnt >= 0x3F00)
	//bhs palread			//r0>=0x3f00就跳到palread
	
	//and r1,r0,#0x3c00
	//adr r2,vram_map		  //vram_map是8个地址	
	//lsr r1,r1,#8
	//ldr r1,[r2,r1]
	//bic r0,r0,#0xfc00	   //and 0x03ff
	//ldrb r1,[r1,r0]
	//ldrb r0,readtemp
	//strb r1,readtemp
		
//inc1_32					  //根据$2002 [bit2] 0：+1  1： +32。	
	//ldr r1,addrcnt
	//ldrb r2,addrcntint
	//add	r1,r1,r2		  //PPU_R0 & 0x04 ? PPU_addrcnt += 32 : PPU_addrcnt++ //
	//str r1,addrcnt
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr

//palread					 ////PPU 读取缓冲不适用 palette 调色板,直接返回
	//and r0,r0,#0x1f
	//adr r1,ppu_palette	 //读取地址
	//ldrb r0,[r1,r2]
	//b inc1_32

	//nop
////===================================================================================================
////----------------------------------------------------------------------------
//ctrl0_W		//(2000)	 //$2000  r0=u8 value
////----------------------------------------------------------------------------
	//strb r0,ppur0	   	   //PPU_R0 = value//

	//mov r2,#1			 //+1/+32 ?  //根据PPU_R0$2002 [bit2] 0：+1  1： +32。
	//tst r0,#4			//测试（执行按位与操作，并且根据结果更新Z 
	//movne r2,#32		//z=0则r2=32
	//strb r2,addrcntint

	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr		
////----------------------------------------------------------------------------
//ctrl1_W		//(2001)
////----------------------------------------------------------------------------
	//strb r0,ppur1	   	   //PPU_R1 = value
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr
////--------------------------------------------------------------------------------							  	 
//ppu2003_W	//$2003
////--------------------------------------------------------------------------------------
	//strb r0,spraddrcnt		 //spr_addrcnt = value//
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr
////-----------------------------------------------------------------------------
//ppu2004_W	//$2004	
////-----------------------------------------------------------------------------------
	//ldr r1,=spr_ram	  //spr_ram[spr_addrcnt++] = value//
	//ldrb r2,spraddrcnt
	//add r2,r2,#1
	//strb r0,[r1,r2]				
	//orr lr,#0x01		//lr最低位置1防止进入arm状态
	//bx lr
////----------------------------------------------------------------------------------------
//bgscroll_W	//$2005
////---------------------------------------------------------------------------------------	   	
	//ldrb r1,toggle		//	 if(PPU_Latch_Flag)
	//eors r1,r1,#1		   //eor Rd, Rn   // Rd ^= Rn  按位）异或	 异或 按位比较相同为0不同位1
	//strb r1,toggle
	//beq bgscrollY
	//strb r0,bg_hscrlorg	   //水平scroll数据 else PPU_BG_HScrlOrg = value////假0：

	//orr lr,#0x01		
	//bx lr
//bgscrollY				//  if(PPU_Latch_Flag) PPU_BG_VScrlOrg	= (value > 239) ? 0 : value////真1：  	
	//cmp r0,#239			//比较  If r0>239 Then （T代表Then，E代表Else）
    //movhi r0,#0
    //strb r0,bg_vscrlorg	 //垂直scroll数据
    //orr lr,#0x01		
	//bx lr
////----------------------------------------------------------------------------
//vmaddr_W	//(2006)
////----------------------------------------------------------------------------
	//ldrb r1,toggle
	//eor r1,#1	  //PPU_Latch_Flag ^= 1//		
	//strb r1,toggle		    
				    ////PPU_addrcnt = (PPU_addrcnt << 8) + value// //PPU 存储器地址计数器，先写高8位，后写低8位
	//ldrb r1,addrcnt		
	//add r2,r0,r1,lsl #8	   //<<8
	//str r2,addrcnt	

	//orr lr,#0x01		
	//bx lr
	//nop
////----------------------------------------------------------------------------
//vmdata_W	//(2007)				 	PPU_MemWrite(value)//
////----------------------------------------------------------------------------
	//ldr r1,addrcnt
////	bic r1,r1,#0xfc000 //AND $3fff
	//and r1,r1,#0x3c00
	//ldr r2,=ppu_vram_write		  //vram_write是8个地址	

	//add r1,r2,r1,lsr#8			  //>>8			
	//ldr pc,[r1]	
	//nop	

////----------------------------------------------------------------------------
//VRAM_name0	//(2000-23ff)		  //PPU name table 数据	
////----------------------------------------------------------------------------
	//ldr r1,addrcnt			//name_table[0][PPU_addrcnt & 0xFFF] = value//	//nametable0
////	and r1,#0x0fff
    //bic r1,r1,#0xf000
	//ldr r2,nes_nt00		//name_table[0]==nes_nt0
	//strb r0,[r2,r1]
	//b inc1_32	
////----------------------------------------------------------------------------
//VRAM_name1	//(2400-27ff)
////----------------------------------------------------------------------------
				 ////name_table[1][addrtemp - 0x400] = value//		//nametable1
	//ldr r1,addrcnt
	//bic r1,r1,#0xf000
	//sub r1,r1,#0x400
	//ldr r2,nes_nt11
	//strb r0,[r2,r1]
	//b inc1_32
////----------------------------------------------------------------------------
//VRAM_name2	//(2800-2bff)
////---------------------------------------------------------------------------
				////name_table[2][addrtemp - 0x800] = value//
	//ldr r1,addrcnt
	//bic r1,r1,#0xf000
	//sub r1,r1,#0x800
	//ldr r2,nes_nt22
	//strb r0,[r2,r1]	
	//b inc1_32
////----------------------------------------------------------------------------
//VRAM_name3	//(2c00-2fff)
////----------------------------------------------------------------------------
			   ////name_table[3][addrtemp - 0xC00] = value//
	//ldr r1,addrcnt
	//bic r1,r1,#0xf000
	//sub r1,r1,#0xc00
	//ldr r2,nes_nt33
	//strb r0,[r2,r1]	
	//b inc1_32
////----------------------------------------------------------------------------
//VRAM_pal	//write to VRAM palette area ($3F00-$3F1F)写入VRAM调色板区
////----------------------------------------------------------------------------	
	//ldr addy,addrcnt	//	 r12
////	cmp addy,#0x3f00	//$3000 ~ $3EFF	-- $2000 ~ $2EFF的镜像
////	bmi VRAM_name3

////	and r0,r0,#0x3f		//(只有颜色0-63都有效)
	//and addy,addy,#0x1f		 // $3F00-$3F1F
		//tst addy,#0x0f
		//moveq addy,#0	//$10 mirror to $00	镜子 对应位置为透明色的景象
	//adr r1,ppu_palette
	//strb r0,[r1,addy]	//store in nes palette  存储在NES调色板
	//b inc1_32

////	nop
////------------------------------------------------------------------------------------------
//ppu_vram_write
	//% 8*4
	//DCD VRAM_name0	//$2000		  |  $2000   |  $23BF   | Name 表 #0                |（960 字节）
	//DCD VRAM_name1	//$2400
	//DCD VRAM_name2	//$2800
	//DCD VRAM_name3	//$2c00		   $2C00   |  $2FBF   | Name 表 #3                |（960 字节）
	//DCD VRAM_name0	//$3000
	//DCD VRAM_name1	//$3400
	//DCD VRAM_name2	//$3800
	//DCD VRAM_pal	//$3c00

////*******************************************************************************************
////-------------------------------------------------------------------------------------
	//AREA wram_globals1, DATA, READWRITE
////-----------------------------------------------------------------------------------------
//ppu_vram_map	//for vmdata_R	vram_map   
	//DCD 0		//图像ROM的8k数据开始地址
	//DCD 0		//图像ROM的8k数据开始地址+1024 
	//DCD 0		//图像ROM的8k数据开始地址+2048
	//DCD 0		//						+3072
	//DCD 0		//						+4096
	//DCD 0	   //
	//DCD 0		//
	//DCD 0		//图像ROM的8k数据开始地址+7168
//nes_nt0 DCD 0 //NES_VRAM+0x2000 //$2000	  显示缓冲区0(VRAM)，与显示屏幕对应的内存区
//nes_nt1 DCD 0 //NES_VRAM+0x2000 //$2400	  显示缓冲区1	 name_table[1]
//nes_nt2 DCD 0 //NES_VRAM+0x2400 //$2800	  显示缓冲区2	 name_table[2]
//nes_nt3 DCD 0 //NES_VRAM+0x2400 //$2c00	  显示缓冲区3	 name_table[3]

			    //DCD 0 //vrombase
				//DCD 0 //vrommask
//PPU_scanline    DCD 0	// scanline	
//PPU_addrcnt	    DCD 0//DCW 0	// addrcnt	u16	
 				//DCD 1		// addrcntint  u8

//PPU_BG_HScrlOrg	DCD 0//DCB 0  //bg_hscrlorg
//PPU_BG_VScrlOrg	DCD 0//DCB 0  //bg_vscrlorg
//PPU_Latch_Flag	DCD 0//DCB 0   //toggle			   背景位移￥2005写入标志	 
//PPU_readtemp 	DCD 0//DCB 0	//readtemp         //读取操作缓冲
//PPU_R0			DCD 0//DCB 0	//ppur0	
//PPU_R1			DCD 0//DCB 0	
//PPU_R2			DCD 0//DCB 0	
//PPU_R5			DCD 0//DCB 0
//spr_addrcnt  	DCD 0//DCB 0	//spraddrcnt  sprite 地址计数器 
			
////				DCB 0	 //保持4字节对齐
////				% 1

//nes_palette	   % 32	//NES $3F00-$3F1F   NES调色板

////------------------------------------------------------------------------

 //END

